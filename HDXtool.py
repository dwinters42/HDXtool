#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Fri Jun 25 12:10:54 2010

# Copyright (c) 2010,2011 Daniel Gruber <daniel@tydirium.org>
#
# Permission to use, copy, modify, and distribute this software for
# any purpose with or without fee is hereby granted, provided that the
# above copyright notice and this permission notice appear in all
# copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
# WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
# AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
# DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
# OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
# TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import wx

# begin wxGlade: extracode
# end wxGlade

import matplotlib
matplotlib.use('WxAgg')

import os, yaml, time
from pylab import *
import scipy.optimize

# set to True to show the fitting in progress
verbose=True

class MainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        
        idnames=['roi','suggest','manual','accept','addlinecomment','deleteline',\
                     'copytoclipboard']

        self.ids = {}
        for title in idnames:
            self.ids[title] = wx.NewId()

        # begin wxGlade: MainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.panel_1 = wx.Panel(self, -1)
        
        # Menu Bar
        self.frame_1_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(wx.ID_OPEN, "&Load\tCtrl+o", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(wx.ID_SAVE, "&Save\tCtrl+s", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(wx.ID_EXIT, "&Quit\tCtrl+q", "", wx.ITEM_NORMAL)
        self.frame_1_menubar.Append(wxglade_tmp_menu, "File")
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(wx.ID_ABOUT, "&Info", "", wx.ITEM_NORMAL)
        self.frame_1_menubar.Append(wxglade_tmp_menu, "About")
        self.SetMenuBar(self.frame_1_menubar)
        # Menu Bar end
        self.frame_1_statusbar = self.CreateStatusBar(1, 0)
        
        # Tool Bar
        self.frame_1_toolbar = wx.ToolBar(self, -1, style=wx.TB_HORIZONTAL|wx.TB_TEXT)
        self.SetToolBar(self.frame_1_toolbar)
        self.frame_1_toolbar.AddLabelTool(wx.ID_OPEN, "Load", (wx.ArtProvider.GetBitmap(wx.ART_FILE_OPEN, wx.ART_TOOLBAR)), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.frame_1_toolbar.AddLabelTool(wx.ID_SAVE, "Save", (wx.ArtProvider.GetBitmap(wx.ART_FILE_SAVE, wx.ART_TOOLBAR)), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.frame_1_toolbar.AddLabelTool(self.ids['roi'], "ROI", (wx.ArtProvider.GetBitmap(wx.ART_GO_FORWARD, wx.ART_TOOLBAR)), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.frame_1_toolbar.AddLabelTool(self.ids['suggest'], "Suggest", (wx.ArtProvider.GetBitmap(wx.ART_GO_FORWARD, wx.ART_TOOLBAR)), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.frame_1_toolbar.AddLabelTool(self.ids['manual'], "Manual", (wx.ArtProvider.GetBitmap(wx.ART_GO_FORWARD, wx.ART_TOOLBAR)), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.frame_1_toolbar.AddLabelTool(self.ids['accept'], "Accept", (wx.ArtProvider.GetBitmap(wx.ART_TICK_MARK, wx.ART_TOOLBAR)), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        # Tool Bar end
        self.listctrlData = wx.ListCtrl(self.panel_1, -1, style=wx.LC_REPORT|wx.LC_AUTOARRANGE|wx.LC_SINGLE_SEL|wx.LC_HRULES|wx.LC_VRULES|wx.SUNKEN_BORDER)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.loadData, id=wx.ID_OPEN)
        self.Bind(wx.EVT_MENU, self.saveData, id=wx.ID_SAVE)
        self.Bind(wx.EVT_MENU, self.onExit, id=wx.ID_EXIT)
        self.Bind(wx.EVT_MENU, self.printInfo, id=wx.ID_ABOUT)
        self.Bind(wx.EVT_TOOL, self.loadData, id=wx.ID_OPEN)
        self.Bind(wx.EVT_TOOL, self.saveData, id=wx.ID_SAVE)
        self.Bind(wx.EVT_TOOL, self.setROI, id=self.ids['roi'])
        self.Bind(wx.EVT_TOOL, self.suggestPeaks, id=self.ids['suggest'])
        self.Bind(wx.EVT_TOOL, self.manualPeaks, id=self.ids['manual'])
        self.Bind(wx.EVT_TOOL, self.acceptPeaks, id=self.ids['accept'])
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.rightClickLine, self.listctrlData)
        # end wxGlade

        self.listctrlData.InsertColumn(0,'#', width=70)
        self.listctrlData.InsertColumn(1,'Low', width=70)
        self.listctrlData.InsertColumn(2,'High', width=70)
        self.listctrlData.InsertColumn(3,'Thres', width=70)
        self.listctrlData.InsertColumn(4,'Centr', width=70)
        self.listctrlData.InsertColumn(5,'Charge', width=70)
        self.listctrlData.InsertColumn(6,'Comment',width=150)

        self.dfile=''
        self.paramfile=''
        self.xdata=None
        self.ydata=None

        # ROI stuff
        self.low=None
        self.high=None
        self.thres=None
        self.hl1=None
        self.hl2=None
        self.hl3=None

        # peaks
        self.peaklist=[]
        self.peaks_sel=None
        self.centroid_line=None

        # fragment data
        self.data=[]
        self.data_changed=False

        self._updateListCtrl()

    def __set_properties(self):
        # begin wxGlade: MainFrame.__set_properties
        self.SetTitle("HDXtool")
        self.frame_1_statusbar.SetStatusWidths([-1])
        # statusbar fields
        frame_1_statusbar_fields = ["Ready"]
        for i in range(len(frame_1_statusbar_fields)):
            self.frame_1_statusbar.SetStatusText(frame_1_statusbar_fields[i], i)
        self.frame_1_toolbar.Realize()
        self.listctrlData.SetMinSize((570,500))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MainFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_2 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_2.Add(self.listctrlData, 1, wx.ALL|wx.EXPAND, 5)
        self.panel_1.SetSizer(sizer_2)
        sizer_1.Add(self.panel_1, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        sizer_1.Fit(self)
        self.Layout()
        # end wxGlade

    def loadData(self, event): # wxGlade: MainFrame.<event_handler>
        dlg=wx.FileDialog(self)
        if dlg.ShowModal() == wx.ID_OK:
            self.dfile=dlg.GetPath()
            del(dlg)
            self.frame_1_statusbar.SetStatusText("Loading data ...")

            # disable windows while data is being loaded
            wx.Yield()
            disabler=wx.WindowDisabler()
            wx.Yield()
            busy=wx.BusyInfo("loading data, please wait ...")
            wx.Yield()
            # load data file, plot data
            wx.Yield()
            d=loadtxt(self.dfile)
            wx.Yield()
            self.xdata=d[:,0]
            self.ydata=d[:,1]
            self.ydata=self.ydata/max(self.ydata)
            figure(1)
            clf();
            plot(self.xdata,self.ydata)

            # load the file with the parameters
            self.data=[]

            self.paramfile=os.path.splitext(self.dfile)[0]+"_params.yml"

            if os.access(self.paramfile, os.R_OK | os.W_OK):
                df=file(self.paramfile,'r')
                try:
                    self.data=yaml.load(df)
                except:
                    wx.MessageBox(\
                        "Cannot read peak data file!","Warning", wx.OK)
                df.close()

                for item in self.data:
                    axvspan(item['low'],item['high'],alpha=0.1,color='k')

            self._updateListCtrl()
            show()
            draw()
            self.data_changed=False
            self.frame_1_statusbar.SetStatusText("Ready")
   
    def setROI(self, event): # wxGlade: MainFrame.<event_handler>
        if self.dfile == '':
            dlg=wx.MessageBox('No data loaded!','Error', wx.ID_OK)
            return

        try:
            self.hl1.remove()
            self.hl2.remove()
            self.hl3.remove()
        except:
            pass

        draw()

        # clear variables
        self.high=None
        self.low=None
        self.thres=None

        # pick threshold and left and right limit
        pos=ginput(1,timeout=0)
        self.thres=pos[0][1]
        self.hl1=axhline(y=self.thres,color='r')
        draw()

        pos=ginput(1,timeout=0)
        self.low=pos[0][0]
        self.hl2=axvline(x=self.low,color='g')
        draw()

        pos=ginput(1,timeout=0)
        self.high=pos[0][0]
        self.hl3=axvline(x=self.high,color='g')
        draw()

        # copy only the data in the region of interest
        self.x=take(self.xdata,find((self.xdata>self.low)&(self.xdata<self.high)))
        self.y=take(self.ydata,find((self.xdata>self.low)&(self.xdata<self.high)))


    def suggestPeaks(self, event): # wxGlade: MainFrame.<event_handler>
        if self.low is None or self.high is None or self.thres is None:
            dlg=wx.MessageBox('No ROI selected!','Error', wx.ID_OK)
            return

        try:
            self.peaks_sel[0].remove()
        except:
            pass

        try:
            self.centroid_line.remove()
        except:
            pass

        # let the user select two peaks
        localpeak1=self._pickpeak(self.x,self.y)
        x1=localpeak1[3]
        y1=localpeak1[1]
        localpeak2=self._pickpeak(self.x,self.y)
        x2=localpeak2[3]
        distance=(max(x1,x2)-min(x1,x2))
        delta=distance*0.05

        ### suggest peaks ###
        # start from startpeak, go to the right until self.high and mark
        # peaks, then do the same to the left
        self.peaklist=[]
        localpeaklist=[localpeak1[0:-1]]

        p=x1+distance
        i=2

        while p<self.high:
            localpeak=self._localpeak((p,0),self.x,self.y,delta,self.thres)
            if localpeak[1]>0 and localpeak[-1]<3 and localpeak[2]>0.0:
                localpeaklist.append(localpeak[0:-1])
            p=x1+distance*i
            i=i+1

        p=x1-distance
        i=2
        
        while p>self.low:
            localpeak=self._localpeak((p,0),self.x,self.y,delta,self.thres)
            if localpeak[1]>0 and localpeak[-1]<3 and localpeak[2]>0.0:
                localpeaklist.append(localpeak[0:-1])
            p=x1-distance*i
            i=i+1

        self.peaklist=vstack(localpeaklist)

        tmp=axis()
        self.peaks_sel=plot(self.peaklist[:,0],self.peaklist[:,1],'go',\
                                self.peaklist[:,3],self.peaklist[:,2]+0.5*self.thres,'co')
        axis(tmp)

        self.centroid=self._centroid(self.low,self.high,self.peaklist)
        self.centroid_line=axvline(x=self.centroid,color='c')
        draw()

    def manualPeaks(self, event): # wxGlade: MainFrame.<event_handler>
        if self.low is None or self.high is None or self.thres is None:
            dlg=wx.MessageBox('No ROI selected!','Error', wx.ID_OK)
            return

        # grey out the suggested peaks if present
        try:
            self.peaks_sel[0].set_color('k')
        except:
            pass
        draw()

        try:
            self.centroid_line.remove()
        except:
            pass

        self.peaklist=[]
        localpeaklist=[]

        # let the user click on the peaks, right click cancels last
        # point, middle button ends
        d=ginput(0,timeout=180)

        ii=axis()
        # XXX this is a bit dodgy
        delta=(ii[1]-ii[0])/200.0

        for p in d:
            localpeak=self._localpeak(p,self.x,self.y,delta,self.thres)
            if localpeak[1]>0 and localpeak[-1]<3 and localpeak[2]>0.0:
                localpeaklist.append(localpeak[0:-1])
        
        self.peaklist=vstack(localpeaklist)

        tmp=axis()
        try:
            self.peaks_sel[0].remove()
        except:
            pass
        self.peaks_sel=plot(self.peaklist[:,0],self.peaklist[:,1],'go',\
                                self.peaklist[:,3],self.peaklist[:,2]+0.5*self.thres,'co')
        axis(tmp)

        self.centroid=self._centroid(self.low,self.high,self.peaklist)
        self.centroid_line=axvline(x=self.centroid,color='c')
        draw()
        
    def acceptPeaks(self, event): # wxGlade: MainFrame.<event_handler>
        if self.low is None or self.high is None or self.thres is None:
            dlg=wx.MessageBox('No ROI selected!','Error', wx.ID_OK)
            return

        if len(self.peaklist) == 0:
            dlg=wx.MessageBox('No peaks selected!','Error', wx.ID_OK)
            return

        # calculate charge state
        charge=1.0/mean(diff(sort(self.peaklist[:,3])))

        self.data.append({'low':float(self.low),\
                              'high':float(self.high),\
                              'thres':float(self.thres),\
                              'centroid':float(self.centroid),\
                              'charge':float(charge),\
                              'peaks':self.peaklist.tolist(),\
                              'comment':''})

        tmp=axis()
        axvspan(self.low,self.high,alpha=0.1,color='k')
        axis(tmp)
        
        self.data_changed=True
        self._updateListCtrl()

        self.centroid_line.remove()
        self.peaks_sel[0].set_color('m')
        self.peaks_sel=None
        draw()

        
    def saveData(self, event): # wxGlade: MainFrame.<event_handler>
        if self.data_changed == True:
            if os.access(self.paramfile,os.R_OK | os.W_OK):
                if wx.MessageBox(\
                    "Data files exist, overwrite?","Overwrite", \
                        wx.YES_NO) == wx.NO:
                    return
        
            df=file(self.paramfile,'w')
            yaml.dump(self.data,df)
            df.close()

            self.data_changed=False
        
    def onExit(self, event): # wxGlade: MainFrame.<event_handler>
        if self.data_changed:
            self.saveData(1)

        close('all')
        self.Destroy()

    def printInfo(self, event): # wxGlade: MainFrame.<event_handler>
        info=wx.AboutDialogInfo()
        info.SetName("HDXtool")
        info.SetDescription("HDX for Clint")
        info.SetCopyright("(c) 2010 Daniel Gruber")
        info.AddDeveloper("Daniel Gruber <daniel@tydirium.org>")
        wx.AboutBox(info)

    def rightClickLine(self, event): # wxGlade: MainFrame.<event_handler>
        # XXX this is overly complicated
        self.item_clicked = int(self.listctrlData.GetItem(event.GetIndex(),0).GetText())
        
        menu = wx.Menu()
        menu.Append(self.ids['addlinecomment'], 'Add comment' )
        wx.EVT_MENU(menu, self.ids['addlinecomment'], self.addComment)
        menu.Append(self.ids['deleteline'], 'Delete Line' )
        wx.EVT_MENU(menu, self.ids['deleteline'], self.deleteLine)
        menu.Append(self.ids['copytoclipboard'], 'Copy all data to clipboard' )
        wx.EVT_MENU(menu, self.ids['copytoclipboard'], self.copyAllDataToClipboard)

        self.panel_1.PopupMenu(menu,event.GetPoint())
        menu.Destroy() 

    def addComment(self,event):
        dlg = wx.TextEntryDialog(self,'Enter comment:','Fragment comment', '')
        if dlg.ShowModal() == wx.ID_OK:
            self.data_changed=True
            self.data[self.item_clicked]['comment']=dlg.GetValue()
            self._updateListCtrl()
        dlg.Destroy()

    def deleteLine(self,event):
        self.data.pop(self.item_clicked)
        self._updateListCtrl()
        self.data_changed=True

    def copyAllDataToClipboard(self,event):
        if not wx.TheClipboard.IsOpened():
            wx.TheClipboard.Open()

        clipdata = wx.TextDataObject()
        s=''
        for ii in range(len(self.data)):
            s=s+'%i\t%f\t%i\t%s\n' % (ii,\
                                        self.data[ii]['centroid'],\
                                        round(self.data[ii]['charge']),\
                                        self.data[ii]['comment'])

        clipdata.SetText(s)
        wx.TheClipboard.Open()
        wx.TheClipboard.SetData(clipdata)
        wx.TheClipboard.Close()

    def _pickpeak(self,x,y):
        ii=axis()
        # XXX this is a bit dodgy
        delta=(ii[1]-ii[0])/200.0
        pos=ginput(1,timeout=0)
        pos=pos[0]
        localpeak=self._localpeak(pos,x,y,delta,self.thres)

        return localpeak

    def _localpeak(self,pos,x,y,delta,thres):

        localx=take(x,find((x>(pos[0]-delta))&(x<(pos[0]+delta))))
        localy=take(y,find((x>(pos[0]-delta))&(x<(pos[0]+delta))))

        # threshold
        localyth=zeros(len(localy))
        for ii in range(0,len(localy)):
            if localy[ii] < thres:
                localyth[ii]=0
            else:
                localyth[ii]=localy[ii]

        # this is a two-stage peak finding
        # first, find the highest y value in delta
        localmax=localyth.max()
        localmaxpos=take(localx,find(localyth==localmax))[0]

        # then, fit a lorentzian in a smaller window delta2 around the
        # maximum, around 2x the expected peak width
        delta2=2*0.003

        # make sure that we fit at least minnumpoints points, even if
        # the spacing in x is too large
        minnumpoints=9
        stepsize=mean(diff(localx))

        if stepsize > 2*delta2/minnumpoints:
            delta2=1.1*minnumpoints/2.0*stepsize

        localx=take(x,find(abs(x-localmaxpos) < delta2))
        localy=take(y,find(abs(x-localmaxpos) < delta2))

        xx=arange(localx[0],localx[-1],0.0001)

        fitfunc = lambda p, x: p[0]/(1+((x-p[1])/p[2])**2)+0.5*thres
        errfunc = lambda p, x, y: fitfunc(p,x)-y

        p0=[localmax,localmaxpos,0.003]
        p1, retcode = scipy.optimize.leastsq(errfunc, p0, args=(localx,localy))

        if verbose:
            figure(2)
            show()
            clf()
            plot(localx,localy,'ro')
            plot(xx,fitfunc(p1,xx),'b-')
            grid(True)
            draw()

            figure(1)
            tmp=axis()
            p=plot(localmaxpos,localmax,'co')
            axis(tmp)
            draw()
            time.sleep(1.0)
            p[0].remove()
            draw()

        return (localmaxpos,localmax,p1[0],p1[1],p1[2],retcode)

    def _centroid(self, low, high, localpeaklist):
        c=0.0
        step=1e-4
        x=arange(low,high,step)
        y=zeros(len(x))

        # construct y values
        for ii in range(len(localpeaklist[:,0])):
            p=localpeaklist[ii,:]
            y=y+p[2]/(1+((x-p[3])/p[4])**2)

        if verbose:
            figure(3)
            show()
            clf()
            plot(x,y)
            draw()
            figure(1)

        # numerically calculate centroid
        for ii in range(0,len(y)):
            c=c+x[ii]*y[ii]

        return c/y.sum()

    def _updateListCtrl(self):
        self.listctrlData.DeleteAllItems()

        for ii in range(len(self.data)):
            ind=self.listctrlData.InsertStringItem(0,'%i' % ii)
            self.listctrlData.SetStringItem(ind,1,'%.3f' % self.data[ii]['low'])
            self.listctrlData.SetStringItem(ind,2,'%.3f' % self.data[ii]['high'])
            self.listctrlData.SetStringItem(ind,3,'%.3f' % self.data[ii]['thres'])
            self.listctrlData.SetStringItem(ind,4,'%.3f' % self.data[ii]['centroid'])
            self.listctrlData.SetStringItem(ind,5,'%i' % round(self.data[ii]['charge']))
            self.listctrlData.SetStringItem(ind,6, self.data[ii]['comment'])


# end of class MainFrame

class MyApp(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        frame_1 = MainFrame(None, -1, "")
        self.SetTopWindow(frame_1)
        frame_1.Show()
        return 1

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
